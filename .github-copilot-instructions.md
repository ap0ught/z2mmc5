# GitHub Copilot Instructions for Z2MMC5

This file provides comprehensive instructions for GitHub Copilot to effectively assist with the Z2MMC5 project.

## Project Context

You are working on **Z2MMC5**, a NES ROM hacking project that converts Zelda II - The Adventure of Link from MMC1 to MMC5 mapper. This is a highly specialized project involving:

- **6502 Assembly Language**: NES CPU architecture
- **MMC5 Mapper**: Advanced memory management controller
- **ROM Hacking**: Binary patching and modification
- **CC65 Toolchain**: CA65 assembler and LD65 linker
- **NES Hardware**: PPU, APU, memory mapping, banking

## Architecture Overview

### Key Files
- `z2mmc5.s`: Main assembly source with banking logic
- `mmc5regs.inc`: MMC5 register definitions and constants
- `z2mmc5.cfg`: Linker script defining memory layout
- `Makefile`: Build system with patch generation
- `compile.bat`: Windows build convenience script

### Core Concepts
- **8KB Banking**: MMC5 uses 8KB PRG banks vs MMC1's 16KB
- **CHR Banking**: 8KB character ROM banking for graphics
- **Patching System**: Surgical modifications to original ROM
- **Free Space**: Utilizing unused areas in original ROM
- **IRQ Handling**: Scanline interrupts for visual effects

## Assembly Language Guidelines

### Syntax (CA65/CC65)
```assembly
; Comments start with semicolon
.include "filename"      ; Include file
.segment "SEGNAME"       ; Define segment
.proc ProcName           ; Define procedure
    ; Local scope
.endproc

; Constants and variables
CONSTANT = $1234
Variable: .byte 0

; Macros
.macro macro_name param1, param2
    lda param1
    sta param2
.endmacro
```

### Register Conventions
```assembly
; A register: Accumulator (8-bit)
; X register: Index register (8-bit) 
; Y register: Index register (8-bit)
; S register: Stack pointer (8-bit)
; P register: Status flags (8-bit)
; PC: Program counter (16-bit)
```

### Memory Addressing
```assembly
; Zero page (fast access)
lda $00         ; Zero page absolute
lda $00,X       ; Zero page indexed

; Absolute addressing  
lda $1234       ; 16-bit address
lda $1234,X     ; Absolute indexed X
lda $1234,Y     ; Absolute indexed Y

; Indirect addressing
jmp ($1234)     ; Indirect jump
lda ($00),Y     ; Indirect indexed
lda ($00,X)     ; Indexed indirect
```

## MMC5 Specific Knowledge

### Register Layout
```assembly
; Banking control
PrgBankModeReg := $5100    ; PRG banking mode
ChrBankModeReg := $5101    ; CHR banking mode

; PRG bank selection
PrgBank8Reg := $5114       ; $8000-$9FFF bank
PrgBankAReg := $5115       ; $A000-$BFFF bank  
PrgBankCReg := $5116       ; $C000-$DFFF bank
PrgBankEReg := $5117       ; $E000-$FFFF bank

; CHR bank selection
BgChrBank0Reg := $5128     ; Background CHR banks
SpChrBank0Reg := $5120     ; Sprite CHR banks

; Control registers
NameTableModeReg := $5105  ; Mirroring control
LineIrqTgtReg := $5203     ; IRQ scanline target
LineIrqStatusReg := $5204  ; IRQ status/enable
```

### Banking Modes
```assembly
; PRG banking modes
PRG_BANK_MODE_32KB = 0      ; 32KB mode
PRG_BANK_MODE_16KB = 1      ; 16KB mode  
PRG_BANK_MODE_16_8KB = 2    ; 16KB + 8KB mode
PRG_BANK_MODE_8KB_BANKS = 3 ; 8KB mode (used)

; CHR banking modes
CHR_BANK_MODE_8KB_BANKS = 0 ; 8KB banks (used)
CHR_BANK_MODE_4KB_BANKS = 1 ; 4KB banks
CHR_BANK_MODE_2KB_BANKS = 2 ; 2KB banks  
CHR_BANK_MODE_1KB_BANKS = 3 ; 1KB banks
```

## Code Patterns

### Bank Switching
```assembly
; Switch PRG bank (8KB at $8000)
.proc SwitchPrgBank8
    ; Input: A = bank number
    ora #PRG_BANK_ROM       ; Set ROM flag ($80)
    sta PrgBank8Reg         ; Write to MMC5 register
    sta CurBank8            ; Update tracking variable
    rts
.endproc

; Switch 16KB bank pair
.proc Switch16kBank  
    ; Input: A = bank number (will use A and A+1)
    asl a                   ; Bank * 2 for 8KB alignment
    ora #PRG_BANK_ROM       ; Set ROM flag
    sta PrgBank8Reg         ; Lower 8KB
    sta CurBank8            ; Track current bank
    
    ora #$1                 ; Next bank  
    sta PrgBankAReg         ; Upper 8KB
    sta CurBankA            ; Track current bank
    rts
.endproc
```

### CHR Bank Switching
```assembly
; Switch CHR bank (background and sprites)
.proc SwitchChrBank
    ; Input: A = bank number
    lsr a                   ; Divide by 2 for alignment
    sta BgChrBank3Reg      ; Set background CHR
    sta SpChrBank7Reg      ; Set sprite CHR
    rts
.endproc
```

### IRQ Handling
```assembly
; Scanline IRQ handler
.proc IrqHdlr
    pha                     ; Save A register
    txa                     ; Save X register
    pha
    
    lda LineIrqStatusReg   ; Clear IRQ status
    
    ; Handle scroll effects
    ldx PpuCtrlForIrq      ; Load PPU control
    lda ScrollPosForIrq    ; Load scroll position
    sta PpuScroll_2005     ; Set scroll X
    lda #$0                
    sta PpuScroll_2005     ; Set scroll Y
    stx PpuControl_2000    ; Set PPU control
    
    pla                     ; Restore X register
    tax
    pla                     ; Restore A register
    rti                     ; Return from interrupt
.endproc
```

### Patching Macros
```assembly
; Define a patchable segment
.macro patch_segment name, size, start_addr, end_addr
    .segment .string(name)
    
    ; Size verification
    .import .ident(.sprintf("__%s_SIZE__", .string(name)))
    .assert .ident(.sprintf("__%s_SIZE__", .string(name))) <= (size), lderror
    
    ; Address verification  
    .ifnblank start_addr
    .import .ident(.sprintf("__%s_LOAD__", .string(name)))
    .assert .ident(.sprintf("__%s_LOAD__", .string(name))) = (start_addr), lderror
    .endif
.endmacro

; Patch a function call
.macro patch_call seg_name, target
    patch_segment seg_name, 3
    jsr target              ; 3 bytes: $20 + 16-bit address
.endmacro

; Patch mirroring setup
.macro patch_set_mirror seg_name, mode  
    patch_segment seg_name, 5
    lda #mode              ; 2 bytes: $A9 + immediate
    sta NameTableModeReg   ; 3 bytes: $8D + 16-bit address
.endmacro
```

## Common Development Tasks

### Adding New Functionality
1. **Identify free space** in ROM banks
2. **Define patch segment** in z2mmc5.cfg
3. **Implement assembly code** using patch_segment macro
4. **Update size constraints** and verify assertions
5. **Test functionality** thoroughly

### Debugging Techniques
```assembly
; Use assertions for validation
.assert CurBank8 >= 0 && CurBank8 <= $F, error, "Invalid bank"

; Add debug labels
DebugPoint1:
    nop                     ; Breakpoint location

; Size checking
.assert * - SegmentStart <= MAX_SIZE, lderror, "Segment too large"
```

### Memory Layout Considerations
- **$8000-$9FFF**: Switchable 8KB bank
- **$A000-$BFFF**: Switchable 8KB bank  
- **$C000-$DFFF**: Switchable 8KB bank
- **$E000-$FFFF**: Fixed bank (Bank F)
- **$6000-$7FFF**: 8KB battery-backed PRG-RAM

## Build System Integration

### Makefile Variables
```makefile
SRC_ROM := "Zelda II - The Adventure of Link (USA).nes"
TGT_NAME := z2mmc5
BUILDDIR := build/$(TGT_NAME)
```

### Generated Files
- **build.inc**: Contains SRC_ROM path definition
- **map.txt**: Memory layout information
- **labels.txt**: Symbol definitions
- **.dbg**: Debug information file

## Best Practices

### Code Organization
1. **Group related functionality** in procedures
2. **Use meaningful labels** and comments
3. **Maintain consistent formatting** and indentation
4. **Document complex algorithms** thoroughly
5. **Verify all assertions** pass during build

### Performance Considerations
1. **Minimize bank switches** in tight loops
2. **Use zero page** for frequently accessed variables
3. **Optimize critical paths** (NMI, IRQ handlers)
4. **Consider instruction timing** for time-sensitive code

### Error Handling
1. **Use assertions** to catch configuration errors
2. **Validate input parameters** in procedures
3. **Check for memory conflicts** in linker output
4. **Test edge cases** thoroughly

## Testing Guidelines

### Emulator Testing
- **Mesen**: Best MMC5 support and debugging tools
- **FCEUX**: Good compatibility and debugger
- **Nestopia**: Basic MMC5 support

### Hardware Testing  
- **EverDrive N8**: Excellent MMC5 support
- **PowerPak**: Good MMC5 compatibility
- **Original MMC5 boards**: Ultimate compatibility test

### Verification Checklist
- [ ] ROM boots correctly
- [ ] Banking functions properly
- [ ] Graphics display correctly
- [ ] Audio plays without issues
- [ ] Save/load works
- [ ] No memory corruption
- [ ] Stable performance

## Troubleshooting Guide

### Common Issues
1. **Segment size exceeded**: Optimize code or find more free space
2. **Banking conflicts**: Check bank usage and timing
3. **Graphics corruption**: Verify CHR banking setup
4. **Audio problems**: Check APU register access
5. **Save issues**: Verify battery-backed RAM configuration

### Debug Resources
- Use debugger to step through code
- Check memory maps for conflicts
- Verify register writes take effect
- Monitor bank switching behavior
- Test with known good ROMs

## Integration with GitHub Copilot

When working with this codebase:

1. **Understand the context**: This is NES assembly, not modern high-level code
2. **Respect hardware constraints**: 6502 CPU limitations, memory layout
3. **Follow existing patterns**: Bank switching, patching system, register usage
4. **Maintain compatibility**: Don't break original game functionality
5. **Test thoroughly**: Emulators and hardware behave differently

### Helpful Prompts
- "Add a new PRG bank switch function for bank X"
- "Implement CHR banking for background graphics"
- "Create an IRQ handler for scanline effects"
- "Patch the mirroring setup at address $XXXX"
- "Optimize this banking routine for speed"

Remember: This is a specialized domain requiring deep knowledge of NES hardware, 6502 assembly, and ROM hacking techniques. Always verify suggestions against NES documentation and test thoroughly.